import 'package:sighttrack/barrel.dart';
import 'package:flutter/material.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart' as mapbox;
import 'package:flutter/services.dart' show rootBundle;
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';

class LocalView extends StatefulWidget {
  const LocalView({super.key});

  @override
  State<LocalView> createState() => _LocalViewState();
}

class _LocalViewState extends State<LocalView> {
  bool _isLoading = true;
  List<Sighting> _sightings = [];
  Map<String, double> _moransIResults = {};
  DateTime? _startTimeFilter;
  mapbox.MapboxMap? _mapboxMap;

  @override
  void initState() {
    super.initState();
    _startTimeFilter = DateTime.now().subtract(const Duration(days: 30));
  }
  

  Future<String?> _getCurrentCityName() async {
    try {
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
      }
      if (permission == LocationPermission.denied ||
          permission == LocationPermission.deniedForever) {
        throw Exception('Location permission not granted');
      }

      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );

      final placemarks =
          await placemarkFromCoordinates(position.latitude, position.longitude);

      if (placemarks.isNotEmpty) {
        print(placemarks.first.locality);
        return placemarks.first.locality;
      }
    } catch (e) {
      debugPrint('Error getting city name: $e');
    }

    return null;
  }

  Future<void> _addMarkersToMap() async {
    if (_mapboxMap == null) return;

    final annotationManager =
        await _mapboxMap!.annotations.createPointAnnotationManager();

    await annotationManager.deleteAll();

    for (var sighting in _sightings) {
      await annotationManager.create(
        mapbox.PointAnnotationOptions(
          geometry: mapbox.Point(
            coordinates: mapbox.Position(sighting.longitude, sighting.latitude),
          ),
          textField: sighting.species,
          textOffset: [0, -2],
          textColor: Colors.white.toARGB32(),
          iconImage: 'marker',
          iconSize: 1.0,
        ),
      );
    }
  }

  latitudelongitude _calculateUserCityCenter() {
    final validSightings = _sightings.where((s) {
      return s.latitude.isFinite &&
          s.longitude.isFinite &&
          s.latitude >= -90.0 &&
          s.latitude <= 90.0 &&
          s.longitude >= -180.0 &&
          s.longitude <= 180.0 &&
          s.city != null &&
          s.city!.isNotEmpty;
    }).toList();

    if (validSightings.isNotEmpty) {
      final citySighting = validSightings.first;
      return latitudelongitude(citySighting.latitude, citySighting.longitude);
    }

    return const latitudelongitude(37.7749, -122.4194);
  }

  Future<void> _resetCameraToUserLocation() async {
    try {
      final pos = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );
      if (_mapboxMap != null) {
        await _mapboxMap!.flyTo(
          mapbox.CameraOptions(
            center: mapbox.Point(
              coordinates: mapbox.Position(pos.longitude, pos.latitude),
            ),
            zoom: 10.0,
            bearing: pos.heading,
          ),
          mapbox.MapAnimationOptions(duration: 500),
        );
        debugPrint('Camera reset to user location: (${pos.latitude}, ${pos.longitude})');
      } else {
        debugPrint('MapboxMap is not initialized.');
      }
    } catch (e) {
      debugPrint('Error resetting camera: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error resetting camera: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final center = _calculateUserCityCenter();

    return Scaffold(
      body: Stack(
        children: [
          Positioned.fill(
            child: mapbox.MapWidget(
              key: const ValueKey('mapWidget'),
              onMapCreated: (controller) async {
                try {
                  Util.setupMapbox(controller);
                  _mapboxMap = controller;

                  await _addMarkersToMap();

                } catch (e) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Map error: $e')),
                  );
                }
              },
              cameraOptions: mapbox.CameraOptions(
                center: mapbox.Point(
                  coordinates: mapbox.Position(
                    center.longitude,
                    center.latitude,
                  ),
                ),
                zoom: 1.0,
              ),
              styleUri: Util.mapStyle,
            ),
          ),
          Positioned(
            bottom: 16,
            right: 16,
            child: FloatingActionButton(
              onPressed: _resetCameraToUserLocation,
              backgroundColor: Colors.grey[850]!.withValues(alpha: 0.9),
              foregroundColor: Colors.white,
              elevation: 6,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(15),
                side: BorderSide(
                  color: Colors.grey[700]!.withValues(alpha: 0.5),
                  width: 1.5,
                ),
              ),
              splashColor: Colors.blueAccent.withValues(alpha: 0.2),
              tooltip: 'Reset to Current Location',
              child: Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withValues(alpha: 0.3),
                      blurRadius: 6,
                      offset: const Offset(0, 3),
                    ),
                  ],
                ),
                child: const Icon(Icons.my_location, size: 24, color: Colors.white),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class latitudelongitude {
  final double latitude;
  final double longitude;

  const latitudelongitude(this.latitude, this.longitude);
}

--------------------------------------------------------------------

import 'package:sighttrack/barrel.dart';
import 'package:flutter/material.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart' as mapbox;
import 'package:geolocator/geolocator.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class LocalView extends StatefulWidget {
  const LocalView({super.key});

  @override
  State<LocalView> createState() => _LocalViewState();
}

class _LocalViewState extends State<LocalView> {
  bool _isLoading = true;
  List<Sighting> _sightings = [];
  Map<String, double> _moransIResults = {};
  DateTime? _startTimeFilter;
  mapbox.MapboxMap? _mapboxMap;
  String? _errorMessage;
  latitudelongitude? _userLocation;

  @override
  void initState() {
    super.initState();
    _startTimeFilter = DateTime.now().subtract(const Duration(days: 30));
    _initializeLocationAndMap();
  }

  Future<void> _initializeLocationAndMap() async {
    try {
      final cityName = await _getCurrentCityName();
      if (cityName != null) {
        await _drawCityBoundaryForCity(cityName);
      } else {
        // Fallback to San Francisco if city cannot be determined
        debugPrint('Falling back to default city: San Francisco');
        await _drawCityBoundaryForCity('SAN FRANCISCO');
      }
      setState(() {
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _isLoading = false;
        _errorMessage = 'Error initializing map: $e';
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error initializing map: $e')),
      );
    }
  }

  
Future<void> _drawCityBoundaryForCity(String cityName) async {
  if (_mapboxMap == null) {
    setState(() {
      _errorMessage = 'Map not initialized';
    });
    return;
  }

  try {
    // Add the vector source for city boundaries (adm2 for city/district level)
    await _mapboxMap!.style.addSource(
      mapbox.VectorSource(
        id: 'boundaries-source',
        url: 'mapbox://mapbox.boundaries-adm2-v4',
      ),
    );

    // Add a line layer to draw the boundaries
    await _mapboxMap!.style.addLayer(
      mapbox.LineLayer(
        id: 'boundaries-layer',
        sourceId: 'boundaries-source',
        sourceLayer: 'boundaries_admin_2',
        lineColor: Colors.red.value, // Bright color for testing visibility
        lineWidth: 6.0, // Thicker line for testing
        lineOpacity: 0.9,
        slot: 'middle', // Ensure layer is visible above base layers, below labels
      ),
    );

    // Normalize city name for case-insensitive matching
    final normalizedCityName = cityName.toUpperCase().trim();

    // Query the source to verify the city name exists in the tileset
    final features = await _mapboxMap!.querySourceFeatures(
      'boundaries-source',
      mapbox.SourceQueryOptions(
        sourceLayerIds: ['boundaries_admin_2'],
        filter: jsonEncode([
          '==',
          ['downcase', ['get', 'name']],
          normalizedCityName,
        ]),
      ),
    );

    if (features == null || features.isEmpty) {
      setState(() {
        _errorMessage = 'City "$cityName" not found in boundaries data';
      });
      // Query all features to log available names and unit_codes
      final allFeatures = await _mapboxMap!.querySourceFeatures(
        'boundaries-source',
        mapbox.SourceQueryOptions(
          sourceLayerIds: ['boundaries_admin_2'],
          filter: jsonEncode(['all']), // Match all features
        ),
      );
      setState(() {
        _errorMessage = 'City "$cityName" not found in boundaries data';
      });
      return;
    }

    // Apply filter to show only the detected city
    await _mapboxMap!.style.setStyleLayerProperty(
      'boundaries-layer',
      'filter',
      jsonEncode([
        '==',
        ['downcase', ['get', 'name']],
        normalizedCityName,
      ]),
    );
  } catch (e) {
    setState(() {
      _errorMessage = 'Error drawing city boundary: $e';
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Error drawing city boundary: $e')),
    );
  }
}


  Future<String?> _getCurrentCityName() async {
  try {
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
    }
    if (permission == LocationPermission.denied ||
        permission == LocationPermission.deniedForever) {
      throw Exception('Location permission not granted');
    }

    final position = await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.high,
    );

    final placemarks =
        await placemarkFromCoordinates(position.latitude, position.longitude);

    if (placemarks.isNotEmpty) {
      print(placemarks.first.locality);
      return placemarks.first.locality; // Returns the city name
    }
  } catch (e) {
    debugPrint('Error getting city name: $e');
  }

  return null;
}

  Future<void> _addMarkersToMap() async {
    if (_mapboxMap == null) return;

    final annotationManager = await _mapboxMap!.annotations.createPointAnnotationManager();
    await annotationManager.deleteAll();

    for (var sighting in _sightings) {
      await annotationManager.create(
        mapbox.PointAnnotationOptions(
          geometry: mapbox.Point(
            coordinates: mapbox.Position(sighting.longitude, sighting.latitude),
          ),
          textField: sighting.species,
          textOffset: [0.0, -2.0],
          textColor: Colors.white.value,
          iconImage: 'marker',
          iconSize: 1.0,
        ),
      );
    }
  }

  latitudelongitude _calculateUserCityCenter() {
    // Prefer user's actual location if available
    if (_userLocation != null) {
      return _userLocation!;
    }

    // Fallback to sightings-based center
    final validSightings = _sightings.where((s) {
      return s.latitude.isFinite &&
          s.longitude.isFinite &&
          s.latitude >= -90.0 &&
          s.latitude <= 90.0 &&
          s.longitude >= -180.0 &&
          s.longitude <= 180.0 &&
          s.city != null &&
          s.city!.isNotEmpty;
    }).toList();

    if (validSightings.isNotEmpty) {
      final citySighting = validSightings.first;
      return latitudelongitude(citySighting.latitude, citySighting.longitude);
    }
    // Default to San Francisco coords if no valid city found
    return const latitudelongitude(37.7749, -122.4194);
  }

  @override
  Widget build(BuildContext context) {
    final center = _calculateUserCityCenter();

    return Scaffold(
      body: SafeArea(
        child: Stack(
          children: [
            mapbox.MapWidget(
              key: const ValueKey('mapWidget'),
              onMapCreated: (controller) async {
                try {
                  Util.setupMapbox(controller);
                  _mapboxMap = controller;
                  await _addMarkersToMap();
                } catch (e) {
                  setState(() {
                    _errorMessage = 'Map error: $e';
                  });
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Map error: $e')),
                  );
                }
              },
              cameraOptions: mapbox.CameraOptions(
                center: mapbox.Point(
                  coordinates: mapbox.Position(
                    center.longitude,
                    center.latitude,
                  ),
                ),
                zoom: 10.0,
              ),
              styleUri: Util.mapStyle,
            ),
            if (_isLoading)
              const Center(child: CircularProgressIndicator()),
            if (_errorMessage != null && !_isLoading)
              Positioned(
                top: 20,
                left: 20,
                child: Container(
                  padding: const EdgeInsets.all(8),
                  color: Colors.white.withOpacity(0.8),
                  child: Text(
                    _errorMessage!,
                    style: const TextStyle(color: Colors.red, fontSize: 16),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class latitudelongitude {
  final double latitude;
  final double longitude;

  const latitudelongitude(this.latitude, this.longitude);
}

------------------------------------------------------

import 'package:sighttrack/barrel.dart';
import 'package:flutter/material.dart';
import 'package:mapbox_maps_flutter/mapbox_maps_flutter.dart' as mapbox;
import 'package:flutter/services.dart' show rootBundle;
import 'package:geolocator/geolocator.dart';
import 'package:geocoding/geocoding.dart';

class LocalView extends StatefulWidget {
  const LocalView({super.key});

  @override
  State<LocalView> createState() => _LocalViewState();
}

class _LocalViewState extends State<LocalView> {
  bool _isLoading = true;
  List<Sighting> _sightings = [];
  Map<String, double> _moransIResults = {};
  DateTime? _startTimeFilter;
  mapbox.MapboxMap? _mapboxMap;

  @override
  void initState() {
    super.initState();
    _startTimeFilter = DateTime.now().subtract(const Duration(days: 30));
  }

  Future<void> _drawCityBoundaryForCity(String cityName) async {
    if (_mapboxMap == null) {
      debugPrint('MapboxMap is not initialized.');
      return;
    }

    try {
      final geoJsonStr = await rootBundle.loadString('assets/city_border.geojson');
      final geo = json.decode(geoJsonStr);

      final features = geo['features'] as List;

      // Normalize and trim the input city name for robust case-insensitive comparison
      final lowerCaseCityName = cityName.toLowerCase().trim();
      debugPrint('Searching for city (normalized input from placemarks): "$lowerCaseCityName"');

      // Find the city feature by name, specifically checking 'properties.name'
      final cityFeature = features.firstWhere(
        (f) {
          final props = f['properties'] ?? {};
          final namePropertyRaw = (props['NAME'] ?? '');
          final namePropertyNormalized = namePropertyRaw.toString().toLowerCase().trim();
          return namePropertyNormalized == lowerCaseCityName;
        },
        orElse: () => null,
      );

      if (cityFeature == null) {
        debugPrint('City "$cityName" (normalized to "$lowerCaseCityName") not found in GeoJSON using "properties.name".');
        return;
      }

      // Ensure the geometry and coordinates exist and are in the expected format
      if (cityFeature['geometry'] == null ||
          cityFeature['geometry']['coordinates'] == null ||
          !(cityFeature['geometry']['coordinates'] is List) ||
          (cityFeature['geometry']['coordinates'] as List).isEmpty) {
        debugPrint('Invalid geometry or coordinates for city "$cityName".');
        return;
      }

      final coordinates = cityFeature['geometry']['coordinates'][0] as List;

      final positions = coordinates.map<mapbox.Position>((point) {
        final lon = point[0] as double;
        final lat = point[1] as double;
        return mapbox.Position(lon, lat);
      }).toList();

      final polygonManager = await _mapboxMap!.annotations.createPolygonAnnotationManager();

      await polygonManager.create(
        mapbox.PolygonAnnotationOptions(
          geometry: mapbox.Polygon(coordinates: [positions]),
          fillColor: const Color(0x000000FF).value,
          fillOutlineColor: const Color(0xff08948c).value,
        ),
      );
      
      debugPrint('City boundary for "$cityName" drawn successfully.');
    } catch (e) {
      debugPrint('Error drawing city boundary: $e');
    }
  }

  Future<String?> _getCurrentCityName() async {
    try {
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
      }
      if (permission == LocationPermission.denied ||
          permission == LocationPermission.deniedForever) {
        throw Exception('Location permission not granted');
      }

      final position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );

      final placemarks =
          await placemarkFromCoordinates(position.latitude, position.longitude);

      if (placemarks.isNotEmpty) {
        print(placemarks.first.locality);
        return placemarks.first.locality;
      }
    } catch (e) {
      debugPrint('Error getting city name: $e');
    }

    return null;
  }

  Future<void> _addMarkersToMap() async {
    if (_mapboxMap == null) return;

    final annotationManager =
        await _mapboxMap!.annotations.createPointAnnotationManager();

    await annotationManager.deleteAll();

    for (var sighting in _sightings) {
      await annotationManager.create(
        mapbox.PointAnnotationOptions(
          geometry: mapbox.Point(
            coordinates: mapbox.Position(sighting.longitude, sighting.latitude),
          ),
          textField: sighting.species,
          textOffset: [0, -2],
          textColor: Colors.white.toARGB32(),
          iconImage: 'marker',
          iconSize: 1.0,
        ),
      );
    }
  }

  latitudelongitude _calculateUserCityCenter() {
    final validSightings = _sightings.where((s) {
      return s.latitude.isFinite &&
          s.longitude.isFinite &&
          s.latitude >= -90.0 &&
          s.latitude <= 90.0 &&
          s.longitude >= -180.0 &&
          s.longitude <= 180.0 &&
          s.city != null &&
          s.city!.isNotEmpty;
    }).toList();

    if (validSightings.isNotEmpty) {
      final citySighting = validSightings.first;
      return latitudelongitude(citySighting.latitude, citySighting.longitude);
    }

    return const latitudelongitude(37.7749, -122.4194);
  }

  Future<void> _resetCameraToUserLocation() async {
    try {
      final pos = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
      );
      if (_mapboxMap != null) {
        await _mapboxMap!.flyTo(
          mapbox.CameraOptions(
            center: mapbox.Point(
              coordinates: mapbox.Position(pos.longitude, pos.latitude),
            ),
            zoom: 10.0,
            bearing: pos.heading,
          ),
          mapbox.MapAnimationOptions(duration: 500),
        );
        debugPrint('Camera reset to user location: (${pos.latitude}, ${pos.longitude})');
      } else {
        debugPrint('MapboxMap is not initialized.');
      }
    } catch (e) {
      debugPrint('Error resetting camera: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error resetting camera: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final center = _calculateUserCityCenter();

    return Scaffold(
      body: SafeArea(
        child: Stack(
          children: [
            mapbox.MapWidget(
              key: const ValueKey('mapWidget'),
              onMapCreated: (controller) async {
                try {
                  Util.setupMapbox(controller);
                  _mapboxMap = controller;

                  await _addMarkersToMap();

                  final cityName = await _getCurrentCityName();
                  if (cityName != null) {
                    await _drawCityBoundaryForCity(cityName);
                  } else {
                    debugPrint('Could not determine user city.');
                  }
                } catch (e) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Map error: $e')),
                  );
                }
              },
              cameraOptions: mapbox.CameraOptions(
                center: mapbox.Point(
                  coordinates: mapbox.Position(
                    center.longitude,
                    center.latitude,
                  ),
                ),
                zoom: 10.0,
              ),
              styleUri: Util.mapStyle,
            ),
            Positioned(
              bottom: 16,
              right: 16,
              child: FloatingActionButton(
                onPressed: _resetCameraToUserLocation,
                backgroundColor: Colors.grey[850]!.withValues(alpha: 0.9),
                foregroundColor: Colors.white,
                elevation: 6,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(15), // Square-ish button
                  side: BorderSide(
                    color: Colors.grey[700]!.withValues(alpha: 0.5),
                    width: 1.5,
                  ),
                ),
                splashColor: Colors.blueAccent.withValues(alpha: 0.2),
                tooltip: 'Reset to Current Location',
                child: Container(
                  width: 48,
                  height: 48,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withValues(alpha: 0.3),
                        blurRadius: 6,
                        offset: const Offset(0, 3),
                      ),
                    ],
                  ),
                  child: const Icon(Icons.my_location, size: 24, color: Colors.white),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class latitudelongitude {
  final double latitude;
  final double longitude;

  const latitudelongitude(this.latitude, this.longitude);
}